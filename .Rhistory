geom_line(aes(t, dexp(t,estim_param_sys1_gph)), color = 'blue') +
xlim(0,40) +
ylim(0,0.17) +
labs(x = "t",
y = "R(t)",
title = "Comparaison entre deux courbes théoriques de la
loi exponentielle pour deux valeurs de lambda avec
les mesures de l'échnatillon")
estim_param_sys1_gph = 0.165511
t = seq(0,40,0.001)
ggplot() +
geom_point(aes(
x = df[,"xi_sys1"],
y = estim_param_sys1_mm*exp(-1*estim_param_sys1_mm*df[,"xi_sys1"])
),
shape = 3,
color = 'black') +
geom_line(aes(t, dexp(t,estim_param_sys1_mm)), color = 'red') +
geom_line(aes(t, dexp(t,estim_param_sys1_gph)), color = 'blue') +
xlim(0,40) +
ylim(0,0.17) +
labs(x = "t",
y = "R(t)",
title = "Comparaison entre deux courbes théoriques de la
loi exponentielle pour deux valeurs de lambda avec
les mesures de l'échnatillon.",
subtitle = "En rouge pour le lambda calculé par méthode des moments
et en bleu pour le lambda trouvé par adéquation graphique.")
ggplot() +
geom_point(aes(
x = df[,"xi_sys1"],
y = estim_param_sys1_mm*exp(-1*estim_param_sys1_mm*df[,"xi_sys1"])
),
shape = 3,
color = 'black') +
geom_line(aes(t, dexp(t,estim_param_sys1_mm)), color = 'red') +
geom_line(aes(t, dexp(t,estim_param_sys1_gph)), color = 'blue') +
xlim(0,5) +
ylim(0,0.17) +
labs(x = "t",
y = "R(t)")
ggplot() +
geom_point(aes(
x = df[,"xi_sys1"],
y = estim_param_sys1_mm*exp(-1*estim_param_sys1_mm*df[,"xi_sys1"])
),
shape = 3,
color = 'black') +
geom_line(aes(t, dexp(t,estim_param_sys1_mm)), color = 'red') +
geom_line(aes(t, dexp(t,estim_param_sys1_gph)), color = 'blue') +
xlim(0,5) +
ylim(0,0.17) +
labs(x = "t",
y = "R(t)") %>% suppressWarnings()
1/estim_param_sys1_mm
ggplot() +
geom_line(aes(x = 1:200, y = df[,"xi_sys2"])) +
labs(x = "N° de mesure",
y = "Durée inter-panne",
title = "Représentation de l'échantillon des
durées inter-pannes pour l'échantillon n°2")
ggplot() +
geom_line(aes(x = 1:1300, y = 1)) +
geom_point(aes(x = df[,"ti_sys2"], y = 1)
, color = "red",
shape = 4) +
labs(x = "t",
y = "",
title = "Représentation des dates de panne pour l'échantillon n°2") +
guides(y = "none")
compute_laplace_stat <- function(T){
n = length(T)
U = sqrt((12)/((n-1)*T[n]^2))
U = U * (sum(T)-(n+1)*T[n]/2)
return(U)
}
compute_laplace_stat <- function(ti){
# Prend le tableau des Ti en entrée de fonction et retourne U
n <- length(ti)
U <- sqrt((12)/((n-1)*ti[n]^2))*(sum(ti)-(n+1)*ti[n]/2)
U %>% as.numeric %>% return()
}
compute_laplace_stat(df[,"ti_sys1"])
qnorm(1-0.05/2, mean = 0, sd = 1)
knitr::opts_chunk$set(cache = TRUE)
library(ggplot2, warn.conflicts = FALSE) # Pour les graphiques
library(magrittr, warn.conflicts = FALSE) # Pour l'opérateur pipe : %>%
library(dplyr, warn.conflicts = FALSE) # Pour la manipulation de dataframe
library(goft, warn.conflicts = FALSE)
# Pour régler la génération aléatoire et conserver les mêmes
# valeurs à la compilation
set.seed(54684)
# Block de code pour effacer le contenu de la mémoire, utile à la compilation
rm(list = ls())
# La fonction read_csv2 est issue du package readr qui permet des imports
# exports facilités dans R
df <- read.csv("../data/RM04data.csv", sep = ',', header = FALSE)
df <- df[1:4,]
columns_names = c("xi_sys1", "xi_sys2", "xi_sys3", "xi_sys4")
observations_labels <- paste('x',as.character(1:200),sep = '')
rownames(df) <- columns_names
colnames(df) <- observations_labels
df <- t(df)
head(df)
dim(df)
df <- cbind(df,cumsum(df[,1]),cumsum(df[,2]),cumsum(df[,3]),cumsum(df[,4]))
columns_names <- c(columns_names,
"ti_sys1", "ti_sys2", "ti_sys3", "ti_sys4")
colnames(df) <- columns_names
head(df)
ggplot() +
geom_line(aes(x = 1:200, y = df[,"xi_sys1"])) +
labs(x = "N° de mesure",
y = "Durée inter-panne",
title = "Représentation de l'échantillon des
durées inter-pannes pour l'échantillon n°1")
ggplot() +
geom_line(aes(x = 1:1300, y = 1)) +
geom_point(aes(x = df[,"ti_sys1"], y = 1)
, color = "red",
shape = 4) +
labs(x = "t",
y = "",
title = "Représentation des dates de panne pour l'échantillon n°1") +
guides(y = "none")
compute_laplace_stat <- function(ti){
# Prend le tableau des Ti en entrée de fonction et retourne U
n <- length(ti)
U <- sqrt((12)/((n-1)*ti[n]^2))*(sum(ti)-(n+1)*ti[n]/2)
U %>% as.numeric %>% return()
}
compute_laplace_stat(df[,"ti_sys1"])
alpha = 0.05
qnorm(1-alpha/2)
compute_bartlett_stat <- function(tn, xi) {
n <- length(xi)
2*n*(log(tn/n)-sum(log(xi))/n)/(1+((n+1)/(6*n))) %>% return()
}
# on calcule la statistique de test
compute_bartlett_stat(df[n,"ti_sys1"], df[,"xi_sys1"])
compute_laplace_stat(df[,"ti_sys2"])
ggplot() +
geom_line(aes(x = 1:200, y = df[,"xi_sys2"])) +
geom_smooth(method = lm) +
labs(x = "N° de mesure",
y = "Durée inter-panne",
title = "Représentation de l'échantillon des
durées inter-pannes pour l'échantillon n°2")
ggplot() +
geom_line(aes(x = 1:1300, y = 1)) +
geom_point(aes(x = df[,"ti_sys2"], y = 1)
, color = "red",
shape = 4) +
labs(x = "t",
y = "",
title = "Représentation des dates de panne pour l'échantillon n°2") +
guides(y = "none")
ggplot() +
geom_point(aes(x = 1:200, y = df[,"xi_sys2"]), shape = 1) +
geom_smooth(method = lm) +
labs(x = "N° de mesure",
y = "Durée inter-panne",
title = "Représentation de l'échantillon des
durées inter-pannes pour l'échantillon n°2")
ggplot() +
geom_line(aes(x = 1:1300, y = 1)) +
geom_point(aes(x = df[,"ti_sys2"], y = 1)
, color = "red",
shape = 4) +
labs(x = "t",
y = "",
title = "Représentation des dates de panne pour l'échantillon n°2") +
guides(y = "none")
ggplot() +
geom_line(aes(x = 1:200, y = df[,"xi_sys2"])) +
labs(x = "N° de mesure",
y = "Durée inter-panne",
title = "Représentation de l'échantillon des
durées inter-pannes pour l'échantillon n°2")
ggplot() +
geom_line(aes(x = 1:1300, y = 1)) +
geom_point(aes(x = df[,"ti_sys2"], y = 1)
, color = "red",
shape = 4) +
labs(x = "t",
y = "",
title = "Représentation des dates de panne pour l'échantillon n°2") +
guides(y = "none")
compute_laplace_stat(df[,"ti_sys2"])
compute_bartlett_stat(df[n,"ti_sys2"], df[,"xi_sys2"])
compute_bartlett_stat(df[n,"ti_sys2"], df[,"xi_sys2"])
compute_bartlett_stat(df[n,"ti_sys2"], df[,"xi_sys2"])
# on calcule la statistique de test
compute_bartlett_stat(df[n,"ti_sys1"], df[,"xi_sys1"])
df[n,"ti_sys1"]
df[n,ti_sys1]
df[n,"ti_sys1"]
df[n,'ti_sys2']
compute_laplace_stat(df[,"ti_sys1"])
df[,"ti_sys1"]
df[n,"ti_sys1"]
# on calcule la statistique de test
compute_bartlett_stat(df[200,"ti_sys1"], df[,"xi_sys1"])
compute_bartlett_stat(df[200,"ti_sys2"], df[,"xi_sys2"])
qchisq(p = 0.025, n-1)
alpha = 0.05 # risque
n = 200 # nombre d'observartion
qnorm(1-alpha/2)
qchisq(p = 0.025, n-1)
qchisq(p = 0.975, n-1)
knitr::opts_chunk$set(cache = TRUE)
library(ggplot2, warn.conflicts = FALSE) # Pour les graphiques
library(magrittr, warn.conflicts = FALSE) # Pour l'opérateur pipe : %>%
library(dplyr, warn.conflicts = FALSE) # Pour la manipulation de dataframe
# Simulation d'une réalisation de la loi de Weibul de paramètre
# thêta et beta
# remplace la fonction rweibull() de R
realisation_aleatoire_weibull <- function(scale = 3, shape = 2.5) {
# Simulation d'une réalisation de la loi de Weibul de paramètre
# thêta et beta
# remplace la fonction rweibull() de R
scale * (-log(runif(1)))^(1/shape) %>% return()
}
realisation_panne_système <- function(n = 4, scale = 3, shape = 2.5) {
# Simulation aléatoire d'une date de panne du système
replicate(n = n,
realisation_aleatoire_weibull(scale = scale, shape = shape)) %>%
min() %>%
return()
}
realisation_panne_système <- function(n = 4, scale = 3, shape = 2.5) {
list_simu <- c()
for (i in 1:n) {
list_simu <- c(list_simu,
realisation_aleatoire_weibull(scale = scale,
shape = shape))
}
return(min(list_simu))
}
# Calcul théorique du MTTFsys
sprintf("MTTFsys théorique calculé : %f ans",
4^(-1/2.5) * 3 * gamma(1 + 1/2.5))
# Simulation d'un MTTF :
sprintf("Une simulation du MTTFsys : %f ans",
mean(replicate(100000,
realisation_panne_système())))
realisation_trajectoire_sys <- function(param, info = FALSE) {
# Fonction pour simuler une trajectoire du système et
# retourner le coût total.
# param est un argument de type list() de la forme :
# param = list(H,x,scale,shape,cmp,cmc)
# Attention :
# H, scale et x sont en jours
# les dates de maintenance préventives prévues
echeancier <- param$x * 1:floor(param$H/param$x)
if (info) {
#debug
print("=== l'échéancier de maintenance préventive ===")
print(echeancier)
print("=== Début de simulation ===")
}
# Le temps courant
t <- 0
# Cout final actuel
Cf <- 0
i <- 1 # un indice
while (t < param$H & i < length(echeancier)) {
next_panne <- t + realisation_panne_système(n = param$n,
scale = param$scale,
shape = param$shape)
if (info) {
# debug
print(paste("Temps courant",t))
print(paste("Date de la prochaine panne : ",next_panne))
print(paste(
"Date de la prochaine maintenance préventive : ",
echeancier[i]))
}
if (next_panne < echeancier[i]) {
# Dans ce cas la prochaine panne si on laisse vivre le système
# arrive avant la prochaine maintenance préventive
# donc on effectue la maintenance corrective
if (info) {print("MC")}
# on met à jour le temps courant
t <- next_panne
# on effectue une maintenance corrective
Cf <- Cf + param$cmc
} else {
if (info) {print("MP")}
# on effecute la maintenance préventive avant une survenue de panne
t <- echeancier[i]
i = i + 1
# on effectue une maintenance préventive
Cf <- Cf + param$cmp
}
if (info) {
print(paste("Temps courant",t))
print(paste("Coût actuel",Cf))
print(paste("val de i",i))
print("---")
}
}
return(Cf)
}
compute_mean_cost_by_time <- function(p = 10000, param_sys) {
# Calcul un coût moyen par unité de temps Cinf(x)
# On chaque trajectoire est divisée par H, l'horizon de simulation
frame <- c()
for (i in 1:p) {
frame <- c(frame,
realisation_trajectoire_sys(param = param_sys,
info = FALSE))
}
frame <- mean(frame/param_sys$H)
return(frame)
}
plot_mean_cost_evolution <- function(list_x, param, p = 1000) {
list_simu <- c()
for (x in list_x) {
param$x <- x
list_simu <- c(list_simu,
compute_mean_cost_by_time(p = p,
param_sys = param))
}
ggplot() +
geom_line(aes(x = list_x, y = list_simu)) +
labs(x = "Périodicité des maintenances",
y = "Coût moyen simulé",
title = "Évolution du coût moyen simulé suivant x")
}
realisation_trajectoire_sys <- function(param, info = FALSE) {
# Fonction pour simuler une trajectoire du système et
# retourner le coût total.
# param est un argument de type list() de la forme :
# param = list(H,x,scale,shape,cmp,cmc)
# Attention :
# H, scale et x sont en jours
# les dates de maintenance préventives prévues
echeancier <- param$x * 1:floor(param$H/param$x)
if (info) {
#debug
print("=== l'échéancier de maintenance préventive ===")
print(echeancier)
print("=== Début de simulation ===")
}
# Le temps courant
t <- 0
# Cout final actuel
Cf <- 0
i <- 1 # un indice
while (t < param$H & i < length(echeancier)) {
next_panne <- t + realisation_panne_système(n = param$n,
scale = param$scale,
shape = param$shape)
if (info) {
# debug
print(paste("Temps courant",t))
print(paste("Date de la prochaine panne : ",next_panne))
print(paste(
"Date de la prochaine maintenance préventive : ",
echeancier[i]))
}
if (next_panne < echeancier[i]) {
# Dans ce cas la prochaine panne si on laisse vivre le système
# arrive avant la prochaine maintenance préventive
# donc on effectue la maintenance corrective
if (info) {print("MC")}
# on met à jour le temps courant
t <- next_panne
# on effectue une maintenance corrective
Cf <- Cf + param$cmc
} else {
if (info) {print("MP")}
# on effecute la maintenance préventive avant une survenue de panne
t <- echeancier[i]
i = i + 1
# on effectue une maintenance préventive
Cf <- Cf + param$cmp
}
if (info) {
print(paste("Temps courant",t))
print(paste("Coût actuel",Cf))
print(paste("val de i",i))
print("---")
}
}
return(Cf)
}
compute_mean_cost_by_time <- function(p = 10000, param_sys) {
# Calcul un coût moyen par unité de temps Cinf(x)
# On chaque trajectoire est divisée par H, l'horizon de simulation
frame <- c()
for (i in 1:p) {
frame <- c(frame,
realisation_trajectoire_sys(param = param_sys,
info = FALSE))
}
frame <- mean(frame/param_sys$H)
return(frame)
}
plot_mean_cost_evolution <- function(list_x, param, p = 1000) {
list_simu <- c()
for (x in list_x) {
param$x <- x
list_simu <- c(list_simu,
compute_mean_cost_by_time(p = p,
param_sys = param))
}
ggplot() +
geom_line(aes(x = list_x, y = list_simu)) +
labs(x = "Périodicité des maintenances",
y = "Coût moyen simulé",
title = "Évolution du coût moyen simulé suivant x")
}
parametres <- list(H = 1000, # on observe sur 1000 ans
x = 1, # on effectue une maintenance préventive tous les
# ans car on a un MTTF de 1.5 environ
n = 4, # nombre de composants
scale = 3, # eta en jours
shape = 2.5, # sans unités
cmc = 10000, # euros
cmp = 1500) # euros
realisation_trajectoire_sys(parametres)
sprintf("Coût moyen pour x = %d an : %f",
parametres$x,
compute_mean_cost_by_time(p = 1000, parametres))
sprintf("Coût moyen pour x = %d an : %f",
parametres$x,
compute_mean_cost_by_time(p = 1000, parametres))
x_values <- seq(1,5,0.5)
parametres <- list(H = 1000, # on observe sur 1002 ans
x = 0, # on effectue une maintenance
#préventive tous les x ans
n = 4,
scale = 3, # eta en jours
shape = 2.5, # sans unités
cmc = 1000, # euros
cmp = 200) # euros
plot_mean_cost_evolution(list_x = x_values, param = parametres)
x_values <- seq(1/12,14/12,1/12)
parametres <- list(H = 1000, # on observe sur 1002 ans
x = 0, # on effectue une maintenance
#préventive tous les x ans
n = 4,
scale = 3, # eta en jours
shape = 2.5, # sans unités
cmc = 1000, # euros
cmp = 200) # euros
plot_mean_cost_evolution(list_x = x_values, param = parametres)
x_values <- seq(8/12,11/12,1/24)
parametres <- list(H = 1000, # on observe sur 1002 ans
x = 0, # on effectue une maintenance
#préventive tous les x ans
n = 4,
scale = 3, # eta en jours
shape = 2.5, # sans unités
cmc = 1000, # euros
cmp = 200) # euros
plot_mean_cost_evolution(list_x = x_values, param = parametres)
setwd("D:/Travail/UTT/Semestres/GI04/RM04/Projets/content")
5/2
0.875*12
realisation_trajectoire_sys_2 <- function(param, info = FALSE) {
# Le temps courant
t <- 0
# Cout final actuel
Cf <- 0
i <- 1 # un indice
if (info) {
print("=== Début de simulation ===")
}
while (t < param$H & i < length(echeancier)) {
echeancier <- param$x * 1:floor((param$H-t)/param$x)
next_panne <- t + realisation_panne_système(n = param$n,
scale = param$scale,
shape = param$shape)
if (info) {
# debug
print(paste("Temps courant",t))
print(paste("Date de la prochaine panne : ",next_panne))
print(paste(
"Date de la prochaine maintenance préventive : ",
echeancier[i]))
}
if (next_panne < echeancier[i]) {
# Dans ce cas la prochaine panne si on laisse vivre le système
# arrive avant la prochaine maintenance préventive
# donc on effectue la maintenance corrective
if (info) {print("MC")}
# on met à jour le temps courant
t <- next_panne
# on effectue une maintenance corrective
Cf <- Cf + param$cmc
} else {
if (info) {print("MP")}
# on effecute la maintenance préventive avant une survenue de panne
t <- echeancier[i]
i = i + 1
# on effectue une maintenance préventive
Cf <- Cf + param$cmp
}
if (info) {
print(paste("Temps courant",t))
print(paste("Coût actuel",Cf))
print(paste("val de i",i))
print("---")
}
}
return(Cf)
}
setwd("D:/Travail/UTT/Semestres/GI04/RM04/projet-2/maintenance-robot-de-peinture")
git status
